<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0053)http://marvin.cs.uidaho.edu/Teaching/CS445/pas06.html -->
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>CS445 - Assignment 6</title>
    <meta name="keywords" content="">
    <meta name="description" content="">
    
    <meta http-equiv="content-language" content="">
    <link href="./CS445 - Assignment 6_files/style.css" rel="stylesheet" type="text/css">
    <link rel="icon" type="image/gif" href="http://marvin.cs.uidaho.edu/Media/Pics/favicon.gif">
</head>

<body><div id="StayFocusd-infobar" style="display:none;">
    <img src="chrome-extension://laankejkbhbdhmipfmgcngdelahlfoji/common/img/eye_19x19_red.png">
    <span id="StayFocusd-infobar-msg"></span>
    <span id="StayFocusd-infobar-links">
        <a id="StayFocusd-infobar-never-show">hide forever</a>&nbsp;&nbsp;|&nbsp;&nbsp;
        <a id="StayFocusd-infobar-hide">hide once</a>
    </span>
</div>
    <div id="page">
        <div id="header">
            <h1><a href="http://marvin.cs.uidaho.edu/Teaching/CS445/pas06.html#">CS445 - Assignment 6</a></h1>
             <p id="subtitle">(Memory address computation)</p>
        </div>   					
        <div id="menu">
            <ul>
                <li><a href="http://marvin.cs.uidaho.edu/index.html">Home</a></li>
                <li><a href="http://marvin.cs.uidaho.edu/Teaching/index.html">Teaching</a></li>
                <li><a href="http://marvin.cs.uidaho.edu/Research/index.html">Research</a></li>
                <li><a href="http://marvin.cs.uidaho.edu/Advising/index.html">Advising</a></li>
                <li><a href="http://marvin.cs.uidaho.edu/Links/index.html">Links</a></li>
                <li><a href="http://marvin.cs.uidaho.edu/About/index.html">About</a></li>
            </ul>
        </div><!-- header -->    
        <div id="main">
            <div id="sidebar">
<p>
REWARD: 150 points <img src="./CS445 - Assignment 6_files/status2.jpg">
</p><p>
DUE: Wed Dec 2 at 5PM PDT

</p><p>
TEST DATA: <a href="http://marvin.cs.uidaho.edu/Teaching/CS445/testDataA6.tar">testDataA6.tar</a>,
<a href="http://marvin.cs.uidaho.edu/Teaching/CS445/testDataA6.zip">testDataA6.zip</a>
</p><hr>
            </div><!-- sidebar -->               
            <div id="content">

<p>

Note that this assignment needs to be done quickly so we can work on
the final code gen phase assignments!   I highly recommend you
start work right away.  I should have assignment 7 up by the second half
of Thanksgiving week if you want to start early on that.

</p><p>

In this assignment you will compute the scope of each variable and
what the address and size is for each variable and constant. This
assignment probably requires about 30 to 50 lines of carefully thought out
code. Do not try to do it at the last minute because it is way too
tricky for that.

</p><p>

You will need to make modifications to the semantic analysis section
and the tree print routine, and maybe the parser depending on what
you have already done. These changes will get your code ready for
code generation. The text below combined with what you learned in
class will tell you what you will need to do to get this to work.

To do this you will need to start by allowing for your tree node
definition to save the size, type of reference, and offset location.
You may already have done this.

You will hijack the tree traversal in your semantic analysis section to
let you use the SymbolTable and scope following you are doing to help
decide where each variable and constant belongs.

You will need two global values a local frame offset,
<tt>foffset</tt>, and a global frame offset, <tt>goffset</tt>. These
need to be decremented appropriately. <tt>foffset</tt> will the offset
from Register 1 for location of the next variable in the frame of the
current function (a parameter or local variable). <tt>goffset</tt> is
similarly designed for the global offset for globally referenced items
(a global or static variable or an array constant like a string).

</p><p>

The results will be that the -M option will now print the location and
scope type for each variable and some extra size information at
compound nodes. Example below.

</p><p>

</p><h3>The Parser</h3>

<p> 

If you haven't already, you need to record the size of every declared
variable at parse time to be very convenient. For local arrays use the
constant size + 1 as the size since the size is stored with the array
in our implementation. For all other items, parameters, globals,
locals use a size of 1.  Also, you need to be sure the variable declaration
nodes are marked as being static or not. </p><p>

</p><h3>The Semantic Analysis Changes</h3>

<p> 

</p><ol>

<p> 

</p><li>You will need to <b>augment the TreeNode</b> struct or class to
handle the <b>offset</b> in local variable space and global space for
variable nodes and the <b>size</b> of the thing to be allocated. How
to do this was discussed in class. (Feel free to ask if you want me to
go over any or all of it again.)

<p>

If you remember, you will maintain pointers for the place in global
memory and the place in local (frame) memory in two offset variables
in the semantic section. You will decrement (the stack and frame grow
down to lower memory addresses) them as you allocate space for each
variable either in the local frame or in the global space. You will
reset the local memory pointer <tt>foffset</tt> when you enter each
function. Don't forget to leave room for the return frame pointer and
return address at the beginning of each activation record (frame).
<b>The result will be that every declaration that requires space will
store the offset of that space and the size in the TreeNode associated
with allocating the space. </b> e.g. the VarK node. A "reference type"
variable in your tree node will help when deciding how to allocate
space and how to reference it at code generation time. So the
reference type in our node will have one of these values: Local,
Static, Parameter, Global. This, will of course, be used to tell you
what offset register to use: 0 or 1 at code generation time as
explained when we discussed the C- memory architecture.

Remember the address of an array points to the first element in the array.
"Before" the first element (next higher addressed spot) is the size of the
array.   So for an array: <tt> int x[10] </tt> the address of the array is
location of <tt>x[0]</tt>.   The size of the array is effectively stored
at <tt>x[-1]</tt> and the total size of the space allocated is 11.
Indexing will be done at run time by subtracting the index from the
address of <tt>x[0]</tt>.

</p><p>

Constants don't normally require that space be allocated in data
memory for them. They are often just loaded from instruction memory as
in the LDC instruction. However, in the case of constant arrays, which
currently we have only defined constant char arrays, you will need to
allocate space. This is done by allocating them as arrays in the
global space.  They are simply global char arrays and so their address
is the address of the first character with the size stored in the location
before the first element.

</p><p>

The offset and size that is used for variables goes unused for all the
rest of the nodes accept for maybe the function declaration and
perhaps, in one implementation, the compound nodes in the final
assignment.

The offset location in function declaration nodes will be used later
for storing the starting instruction address of the function so that
it can be looked up in the symbol table and we can jump to the various
functions. It can be initialized to zero. The function symbol is, of
course, global.

</p><p>

</p></li><li> The symbol table is already used to point to the TreeNodes so you
can now find the offset, size, and reference type of <b>every</b>
reference to a variable (ID node) when you arrive at them and look
them up in the symbol table. You can now copy that information for use
in those referencing nodes.

<p>

</p></li><li> When you leave the semantic analysis section the symbol table
will have been reduced back down to just the global scope. If you
freed the symbol table before... don't now... you should <b>pass
symbol table of globals</b> along with the <b>end of the global
space</b> pointer (<tt>goffset</tt>) to the code generation section as
described below! This will be used for doing such things as
initializing global and static variables and setting up the frame
stack.

<p>

It is assumed that the <tt>foffset</tt> pointer will be saved when
entering a new scope and restored on exit so the memory can be
reclaimed as explained in class. This was called <b>overlaying
memory</b> or <b>parallel compound statements</b>. Be sure your code
does this. You might start by not doing it and then later add the few
lines that makes that work. If you don't get this right a lot of your
memory locations will be wrong.

</p><p>

</p></li></ol>
<p>

The code will be tested by comparing the results of doing <tt>c-
-M</tt> which will print an augmented tree as seen below:

</p><p>

</p><pre>1 int g, gg[10];
2
3 julia(int x, y, z)
4 {
5     int a, aa[10];
6     bool b, bb[20];
7     char c, cc[30];
8     static int s, t;
9
10     a = x;
11     cc = "reconnaissance";
12
13     { int p; }
14     { int q; }
15 }
16
17 int h;
18
19 main();
</pre>
<p>
The output of c- -M mem2.c-
</p><pre>Sibling: 1  Var gg: array of type int [mem: Global  size: 11  loc: -2] [line: 1]
Sibling: 2  Func julia: returns type void [line: 3]
.   Child: 0  Param x: type int [mem: Param  size: 1  loc: -2] [line: 3]
.   Sibling: 1  Param y: type int [mem: Param  size: 1  loc: -3] [line: 3]
.   Sibling: 2  Param z: type int [mem: Param  size: 1  loc: -4] [line: 3]
.   Child: 1  Compound [line: 4]
.   .   Child: 0  Var a: type int [mem: Local  size: 1  loc: -5] [line: 5]
.   .   Sibling: 1  Var aa: array of type int [mem: Local  size: 11  loc: -7] [line: 5]
.   .   Sibling: 2  Var b: type bool [mem: Local  size: 1  loc: -17] [line: 6]
.   .   Sibling: 3  Var bb: array of type bool [mem: Local  size: 21  loc: -19] [line: 6]
.   .   Sibling: 4  Var c: type char [mem: Local  size: 1  loc: -39] [line: 7]
.   .   Sibling: 5  Var cc: array of type char [mem: Local  size: 31  loc: -41] [line: 7]
.   .   Sibling: 6  Var s: static type int [mem: Static  size: 1  loc: -12] [line: 8]
.   .   Sibling: 7  Var t: static type int [mem: Static  size: 1  loc: -13] [line: 8]
.   .   Child: 1  Assign = : type int [line: 10]
.   .   .   Child: 0  Id a: type int [mem: Local  size: 1  loc: -5] [line: 10]
.   .   .   Child: 1  Id x: type int [mem: Param  size: 1  loc: -2] [line: 10]
.   .   Sibling: 1  Assign = : array of type char [line: 11]
.   .   .   Child: 0  Id cc: array of type char [mem: Local  size: 31  loc: -41] [line: 11]
.   .   .   Child: 1  Const "reconnaissance" : array of type char [mem: Global  size: 15  loc: -15] [line: 11]
.   .   Sibling: 2  Compound [line: 13]
.   .   .   Child: 0  Var p: type int [mem: Local  size: 1  loc: -71] [line: 13]
.   .   Sibling: 3  Compound [line: 14]
.   .   .   Child: 0  Var q: type int [mem: Local  size: 1  loc: -71] [line: 14]
Sibling: 3  Var h: type int [mem: Global  size: 1  loc: -29] [line: 17]
Sibling: 4  Func main: returns type void [line: 19]
Number of warnings: 10
Number of errors: 0
</pre>

            </div><!-- content -->
            <div class="clearing">&nbsp;</div> 
        </div><!-- main -->
    </div><!-- page -->
    <div id="footer">

        <p>Copyright © 2012, original design by <a href="http://www.alphastudio.pl/" target="_blank">Alpha Studio</a> transfigured by R. Heckendorn

</p>
    </div>


<div class="betternet-wrapper"></div></body></html>
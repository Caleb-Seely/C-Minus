<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0053)http://marvin.cs.uidaho.edu/Teaching/CS445/pas03.html -->
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>CS445 - Assignment 3</title>
    <meta name="keywords" content="">
    <meta name="description" content="">
    
    <meta http-equiv="content-language" content="">
    <link href="./CS445 - Assignment 3_files/style.css" rel="stylesheet" type="text/css">
    <link rel="icon" type="image/gif" href="http://marvin.cs.uidaho.edu/Media/Pics/favicon.gif">
</head>

<body><div id="StayFocusd-infobar" style="display:none;">
    <img src="chrome-extension://laankejkbhbdhmipfmgcngdelahlfoji/common/img/eye_19x19_red.png">
    <span id="StayFocusd-infobar-msg"></span>
    <span id="StayFocusd-infobar-links">
        <a id="StayFocusd-infobar-never-show">hide forever</a>&nbsp;&nbsp;|&nbsp;&nbsp;
        <a id="StayFocusd-infobar-hide">hide once</a>
    </span>
</div>
    <div id="page">
        <div id="header">
            <h1><a href="http://marvin.cs.uidaho.edu/Teaching/CS445/pas03.html#">CS445 - Assignment 3</a></h1>
             <p id="subtitle">(Semantic Analysis and Typing)</p>
        </div>   					
        <div id="menu">
            <ul>
                <li><a href="http://marvin.cs.uidaho.edu/index.html">Home</a></li>
                <li><a href="http://marvin.cs.uidaho.edu/Teaching/index.html">Teaching</a></li>
                <li><a href="http://marvin.cs.uidaho.edu/Research/index.html">Research</a></li>
                <li><a href="http://marvin.cs.uidaho.edu/Advising/index.html">Advising</a></li>
                <li><a href="http://marvin.cs.uidaho.edu/Links/index.html">Links</a></li>
                <li><a href="http://marvin.cs.uidaho.edu/About/index.html">About</a></li>
            </ul>
        </div><!-- header -->    
        <div id="main">
            <div id="sidebar">
<p>
REWARD: 280 points   <img src="./CS445 - Assignment 3_files/status3.jpg">
</p><p>
DUE: Sun Oct 25 at 5PM PDT 
</p><p>
TEST DATA:
(partially available)
<a href="http://marvin.cs.uidaho.edu/Teaching/CS445/testDataA3.tar">testDataA3.tar</a>,
<a href="http://marvin.cs.uidaho.edu/Teaching/CS445/testDataA3.zip">testDataA3.zip</a>
</p><hr>

            </div><!-- sidebar -->               
            <div id="content">

<h3>The Problem</h3>
<p>
In this assignment we will type our expressions in the abstract syntax tree (AST) and
start to do semantic analysis and semantic error generation.
We will also be checking to be sure variables are declared before use.   And
we'll even be able to warn when a variable might not be initialized before use.

</p><h3>New Compiler Options</h3>
<p>

This time you have four options on the command line.
<el>

</el></p><li>The <tt>-d</tt>
option from which sets the yydebug variable to 1.

</li><li>The <tt>-P</tt> option (lower case p) which prints the abstract
syntax tree. That is, it prints the syntax tree we did for assignment
2, but with types added. This is true for symbols both at the
declaration and at point of use. The symbol table below will help with
that.

</li><li>The <tt>-S</tt> option turns on symbol table debugging.
This will cause a line of information to be printed out for every
action you perform with the symbol table.   Just set debugging
in the SymbolTable object.

</li><li>The <tt>-h</tt> option prints out this usage message:
<pre>Usage: c- [options] [sourceFile]
  -d  turn on Bison debugging
  -h  this usage message
  -P  print abstract syntax tree + types
  -S  turn on symbol table debugging
</pre>


<p>
c- should still accept a single input file either from a filename
given on the command line or redirected as standard input.

</p><h3>Reorganize your Code</h3>

<p>
Put your
semantic analysis code in <tt>semantic.cpp</tt> and
<tt>semantic.h</tt>.  If you use my ourgetopt routine then put that
in <tt>ourgetopt.cpp</tt> and <tt>ourgetopt.h</tt>.  Update your makefile
to build these by putting their <tt>.o</tt>'s in the dependency
list for building c- and in the g++ line.

</p><h3>Semantic Errors</h3>

<p> 
We want to generate errors that are tagged with useful line numbers.
So we will need to be sure each node is tagged with a useful line
number. Remember, to do this effectively we need to grab the line
number as soon as possible (in flex) and associate it with the token.
This can be done nicely (portably) by passing back a struct/class for
each token (as you have probably already done) in the yylval which has
all the information about the token such as its line number, lexeme
(what the user typed), constant value, even token class. (A
struct/class allows you to return more than a single value in yylval.)
You should avoid using global variables for token information when
possible because the parser looks ahead and may already be onto the next token.

</p><p>
Once the information is passed back in the tokenData, then things like
the line number, size, type, etc may be squirreled away in the TreeNodes in the tree!
This information is then used when the tree is traversed for semantic
analysis.

</p><h3>Scope and Type Checking</h3> 
<p> 

After checking if you should print the abstract syntax tree, you will
now traverse the tree looking for typing and
program structure errors.  So your main() might look something like
this:
</p><pre>	numErrors=0; 
        numWarnings=0;

	yyparse();

	if (numErrors==0) {
            symbolTable = new SymbolTable();
            semanticAnalysis(syntaxTree, symbolTable);   // semantic analysis (may have errors)

            // -P
            if (printAnnotatedSyntaxTree) printTree(syntaxTree, TYPES);

            // code generation will go here

            }

        // report the number of errors and warnings
        printf("Number of errors: %d\n", numErrors);
        printf("Number of warnings: %d\n", numWarnings);
</pre> 

<p> Your main may look quite different. I do a couple of other setup
things for instance. The routine semanticAnalysis will process the tree
by calling a treeTraverse routine that starts at the root node for the
AST and recursively calls itself for children and siblings until it
gets to the leaves. Declarations will make entries in a symbol table
(see the symbol table section below). References to symbols will be
looked up in the symbol table.

</p><p>
Your job in writing the treeTraverse routine is to catch a variety of
warnings and errors and duplicate my output for any input given.
For this assignment, all input will be syntactically legal but there may
be many semantic errors.   (In a couple of assignments we'll come back
and look at normalizing all errors.)

</p><p> You should keep count of the number of warnings and errors and
report that at the end of a run. Here is <a href="http://marvin.cs.uidaho.edu/Teaching/CS445/errorMsgs03.txt"> the
list of errors right out of my version</a> in printf format. To get an
easy match to the expected output it helps you immensely if you just
use exactly these formats. Note that the type string that you put into
the message is often something like "type int" or "unknown type".
<b>These are exactly the errors you must catch for this assignment</b>
There are 18 error messages and 2 warnings for this assignment. There
will be the other half of the errors in the next assignment.

</p><p>
Here are some details by node type but this list is NOT EXHAUSTIVE.
You are in control of the design as long as it duplicates my output.

</p><ul>
<li> For <b>declaration nodes</b> check for duplicate declarations using the symbol
table.  A special case happens in the case of the first compound statement
in a function which will NOT open a new scope:
<p>
</p><pre>fred(int x) { int x; }
</pre>
<p>
is a duplicate definition of x while
</p><p>
</p><pre>fred(int x) { { int x; } }
</pre>
<p>
is not.   This is what C++ does.  Try it.

</p></li><li> For <b>compound statements</b> a newScope needs to be handled.
The symbol table object I supply will let you set up and destroy
scopes, enter variables in the symbol table and check for a variable
definition. For documentation purposes, you can put a label of your
choice on a new scope in the <b>enter</b> method for the SymbolTable
object. For instance: <b>enter("Compound Statement");</b> to label the
scope. If you turn on debugging using a good label for each scope
might help make the debug information more readable.

</li><li> <b>Assignments</b> and <b>operators</b> should check that they
have the proper type. Types of expressions will have to be passed up
up the tree so they can be checked by the operators that use them.
Beware of <b>Cascading Errors</b> as discussed in class. Hint: two
things you can do: Many operators have an assumed return type. For
example '+' returns an int. Be sure to set that. Second, it might be
useful to have an undefined type that is used when variables have not
been declared or the type is undefined.

</li><li>
Consider using an array or clever function rather than a switch or
"cascading if" to know what types <b>operators</b> require for the
operand and use the same strategy for remembering what
type is returned.  Hint: I have intentionally limited the
number of cases for type checking.  It is easy to code up
those as functions you can invoke based on what the operator expects.
Some examples are:
<ul>
<li> &gt; takes Integers and returns a Boolean.
</li><li> + takes Integers and returns an Integer.
</li><li> | takes Booleans and returns a Boolean. 
</li><li> The operators <b>==</b> and <b>!=</b>,
take arguments that are of the same type (e.g. both Boolean 
or both Integer) and return a Boolean.  They can be arrays.
</li><li> <b>=</b> take arguments that are of the same type
and returns the type of the lhs.   This means if there
is an undefined operand, the lhs operand even if undefined
is the type of the assignment.
This is because assignment is an expression
and can be used in cascaded assignment like:  a = b = c = 314159265
</li><li> <b>++</b>  and <b>--</b> takes in Integer and immediately returns and Integer.
This is <b>not</b> like in C or C++ in which these operators have special semantics.
</li></ul>
See the error
messages above to find an appropriate error message.  Note that
in the error messages above
<b>lhs</b> means left hand side and 
<b>rhs</b> means right hand side. 
<p>
See the c-Grammar for tables of operators and what types of arguments they take
and what type they will return.

</p></li><li> For <b>Ids</b> you have to see if the variable has been
previously declared or not. This can be done by creating special flag
<b>isUsed</b> in the treeNode. You can then lookup the declaration
node in the symbolTable and set and query the flag in that node. If
not previously declared, set the type of the Id node to the type of
the declaration and put a pointer to the declaration node in the
symbolTable. VERY IMPORTANT: This way you can always find your way
back to the declaration node in the tree and store all the information
about a variable at its declaration!

If the Id is undeclared, then set the type of the id to
<b>UndefinedType</b> (or some other indicator that the type
information is missing).  To prevent cascading errors, undefined types
do not create an error when compared to an expected type.   It is assumed an
error was generated when the type was marked undefined.

</li><li> IMPORTANT: Note that for this assignment each undeclared
reference must generate an error message.  We'll fix this later.
 
</li><li> We issue a warning for the possibility that a variable is being
used that was uninitialized. This only applies to strictly locally
declared variables, not globals, statics, or parameters. If a
variable's rhs value is used before (appears in the tree traversal
before) it has been initialized or appeared on the lhs a warning is
issued. So being on the lhs in a binary assignment or being initialized on
declaration will cause the variable to be marked as initialized.
This is very similar to the used warning code.

</li><li> For Ids you can have <b>arrays</b> that are indexed.  Once they are
indexed, their type becomes nonarray.  That is the type of the
'[' is the type of the lhs.   Check for indexing
of nonarrays and using unindexed arrays where they can't be used.

</li><li> void is the type of a function that intentionally returns no value.
It is possible for a type to be of type void in an error message.

</li><li> Ids that are arrays can also be prefixed with '*' operator.
That lets you get at the size of the array.  Every array stores
not only the values in the array but its size.  This means that
an array of size 10 (e.g. frog[10]) needs 11 spaces allocated to
it.  More about this in the memory allocation assignment.
For this assignment you only need to know that '*' works on
arrays and returns an int.

</li><li> The <b>return</b> statement you must make sure that the user does
not try to return a whole array.

</li><li>  Finally, after processing the whole tree, <b>main</b> should be
in the global symbol table.  If the procedure main is not defined then
you must print out an error.
</li></ul>


<h3>Symbol Table</h3>
<p>
Here is a useful C++ symbol table object you can use:
</p><p>
<a href="http://marvin.cs.uidaho.edu/Teaching/CS445/symbolTable.tar">tar of C++ symbol table stuff</a><br>
</p><p>
Please use the version from Oct 1, 2020 or later.
This version uses C++ standard library.   Feel free to augment it
or build your own.  Though it is written with std::string
type as the argument type in many places, you can cast a char *
to and from std::string.

</p><p>
The symbol table object with insert and lookup methods for
symbols and a pointer (you can use the pointer to point to a TreeNode.
It also has enter and leave methods of managing the scope stack.  You should
always access symbols through the symbol table object and you should never have
to access a scope object.  The scopes are managed by enter and leave methods.  Read
the symbolTable.h for more information on how to use it.  You might want to
just play with it to see how it works before you put it into your
compiler (see test routines commented out in the supplied code.).
Inserting a symbol that is already defined returns false, success returns true.
Looking up a symbol that is not there will return a NULL pointer.

</p><p> One feature of the symbol table is the debug flag. At construction
time the SymbolTable object is in nondebugging mode. But by setting
the flag with the debug method you can get the object to spew out
info. You can also just print the symbol table if using the provided
print routine. You might consider starting out by printing the symbol
table on exit from a scope using the debug flag.

</p><p> Finally the symbol table print routine takes a print function that
will print your treeNode. So if you define something to print a node
given a TreeNode * then you can supply that name to the print function
to print out your symbol table stack. That way the code doesn't have
to know what you TreeNode looks like internally. For instance in my
code:

</p><pre> 
    symtab = new SymbolTable();
</pre>
creates the symbol table.  To print the symbol table:
<pre> 
    symtab-&gt;print(nodePrint);
</pre>
will print each void * in the symbol table using
your supplied function:
<pre>    void nodePrint(void *p)
</pre>
<p>
 
</p><h3>Submission</h3>

<p> Homework will be submitted as an <b>uncompressed</b> tar file
that contains no subdirectories. The tar file is submitted to the
class submission page. You can submit as many times as you like.
<b>The LAST file you submit BEFORE the deadline will be the one
graded.</b> Absolutely, no late papers. For all submissions you will
receive email at your uidaho address showing how your file performed
on the pre-grade tests. The grading program will use more extensive
tests, so thoroughly test your program with inputs of your own.

</p><p>
Your code should compile and run without runtime errors such as seg faults.
If it doesn't, it is considered nearly ungradable.

            </p></li></div><!-- content -->
            <div class="clearing">&nbsp;</div> 
        </div><!-- main -->
    </div><!-- page -->
    <div id="footer">
        <p>Copyright Â© 2012, original design by <a href="http://www.alphastudio.pl/" target="_blank">Alpha Studio</a> transfigured by R. Heckendorn
</p>
    </div>


<div class="betternet-wrapper"></div></body></html>